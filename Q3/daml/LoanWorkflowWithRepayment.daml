module LoanWorkflowWithRepayment where

import DA.Action
import DA.Foldable as F
import DA.List as L
import DA.Map as M
import DA.Map.Extra as ME
import DA.Optional
import DA.Traversable as T
import DA.Tuple as TU

-- Helper function to calculate the total of tokens, ignoring signs
tokenValue : [Token] -> Decimal
tokenValue = F.sum . fmap (.value)

-- Helper function to calculate the tokens required to repay a specified amount
getTokensForRepayment : Decimal -> Map (ContractId Token) Token -> Map (ContractId Token) Token
getTokensForRepayment repaymentAmount tokenMap =
  let (greaterThanOrEqualToRepaymentAmount, lessThanRepaymentAmount) = 
        ME.partition ((>= repaymentAmount) . (.value)) tokenMap
  in
    if not $ M.null greaterThanOrEqualToRepaymentAmount
    then ME.head greaterThanOrEqualToRepaymentAmount
    else
        let folder k v (out, acc) = 
              if acc - v.value >= 0.0
              then (M.insert k v out , acc - v.value)
              else (out, 0.0)
        in  fst $ ME.foldrWithKey folder (M.empty, repaymentAmount) lessThanRepaymentAmount

-- Helper function to fetch all Token contracts from a list of ContractIds
getDisbursements : HasFetch a => [ContractId a] -> Update [a]
getDisbursements = T.mapA fetch

getDisbursementMap : HasFetch a => [ContractId a] -> Update (Map (ContractId a) a)
getDisbursementMap contractIds =
  M.fromList <$> T.mapA (T.mapA fetch) dupes
    where dupes = fmap TU.dupe contractIds

createTokenForChange : Party -> Party -> Decimal -> [Token] -> Optional Token
createTokenForChange minter owner repayment tokens =
  if totalTokenValue <= repayment
  then None
  else Some $ Token with value = repayment - totalTokenValue; ..
    where totalTokenValue = tokenValue tokens

addChangeToDisbursements : Optional (ContractId Token) -> [ContractId Token] -> [ContractId Token]
addChangeToDisbursements (Some cid) = (cid ::)
addChangeToDisbursements None = identity

updateLoanLimit : Decimal -> LoanLimit -> LoanLimit
updateLoanLimit closedLoan originalLimit =
  originalLimit with amount = newLimit
    where newLimit = originalLimit.amount + closedLoan

template Token
  with
    value : Decimal
    minter : Party
    owner : Party
  where
    signatory minter
    observer owner
    ensure value > 0.0

template LoanLimit
  with
    amount : Decimal
    bank : Party
  where
    signatory bank
    ensure amount > 0.0
    key bank : Party
    maintainer key

template RepaymentRestriction
  with
    minimumAmount : Decimal
    bank : Party
    borrower : Party
    loanId : Text
  where
    signatory bank, borrower
    ensure minimumAmount > 0.0 && bank /= borrower
    key (bank, borrower, loanId) : (Party, Party, Text)
    maintainer key._1

template RepaymentDelegation
  with
    borrower : Party
    bank : Party
    loanId : Text
  where
    signatory bank, borrower
    ensure bank /= borrower
    nonconsuming choice RepayLoan : Optional (ContractId Loan)
      with
        loanCid : ContractId Loan
        amount : Decimal
      controller bank
      do
        newLoanCidOpt <- exercise loanCid Repay with .. 
        when (isNone newLoanCidOpt) (archive self)
        pure newLoanCidOpt

template RepaymentDelegationProposal
  with
    borrower : Party
    bank : Party
  where
    signatory borrower
    observer bank
    ensure bank /= borrower
    choice Accept : ContractId RepaymentDelegation
      with
        loanId : Text
      controller bank
      do
        create RepaymentDelegation with ..

template Loan
  with
    id : Text
    bank : Party
    borrower : Party
    approvedAmount : Decimal
    repaidAmount : Decimal
    disbursementCids : [ContractId Token]
  where
    signatory bank, borrower
    key (bank, borrower, id) : (Party, Party, Text)
    maintainer key._1
    ensure approvedAmount > 0.0 && repaidAmount >= 0.0 && bank /= borrower

    choice Disburse : (ContractId Token, ContractId Loan)
      with
        amount : Decimal
        actor : Party
      controller actor
      do
        assertMsg "Actor must be either be the borrower or the bank" (actor `L.elem` [borrower, bank])
        assertMsg "Must disburse more than zero" (amount > 0.0)
        assertMsg "Cannot disburse more than approved amount" (amount <= approvedAmount)

        existingDisbursements <- getDisbursementMap disbursementCids

        let existingDisbursementTotal = tokenValue $ values existingDisbursements
        let newDisbursementTotal = amount + existingDisbursementTotal

        assertMsg "Total disbursement amount cannot be more than approved amount" (newDisbursementTotal <= approvedAmount)

        let disbursement = 
              Token with value = amount; owner = borrower; minter = bank
        newDisbursementCid <- create disbursement
        newLoanCid <- create this with disbursementCids = newDisbursementCid :: keys existingDisbursements

        pure (newDisbursementCid, newLoanCid)

    choice Repay : Optional (ContractId Loan)
      with
        loanId : Text
        amount : Decimal
      controller borrower
      do
        assertMsg "Repayment amount must be greater than zero" (amount > 0.0)

        (repaymentRestrictionCid, repaymentRestriction) <- fetchByKey @RepaymentRestriction (bank, borrower, loanId)
        assertMsg "Repayment amount must be greater than minimum amount specified in repayment restriction" (amount > repaymentRestriction.minimumAmount)

        existingDisbursements <- getDisbursementMap disbursementCids

        let repaymentTokens = getTokensForRepayment amount existingDisbursements
            repaymentValue = tokenValue $ values repaymentTokens
            newRepaidAmount = repaidAmount + repaymentValue
            canCloseLoan = newRepaidAmount >= approvedAmount

        if canCloseLoan
        then do
          mapA_ archive disbursementCids

          archive repaymentRestrictionCid

          (loanLimitCid, loanLimit) <- fetchByKey @LoanLimit bank
          let newLimit = updateLoanLimit approvedAmount loanLimit
          archive loanLimitCid
          void $ create newLimit

          pure None

        else do
          let changeOpt = createTokenForChange bank borrower amount (values repaymentTokens)
          changeCidOpt <- T.mapA create changeOpt

          let newDisbursementCids = 
                addChangeToDisbursements changeCidOpt $ disbursementCids \\ keys repaymentTokens

          mapA_ archive $ keys repaymentTokens
          
          Some <$> create this with repaidAmount = newRepaidAmount; disbursementCids = newDisbursementCids 

template LoanRequest
  with
    bank : Party
    borrower : Party
    amount : Decimal
  where
    signatory borrower
    observer bank
    ensure amount > 0.0 && bank /= borrower

    choice ApproveRequest : ContractId Loan
      with
        loanId : Text
        minimumRepaymentAmount : Decimal
      controller bank
      do
        assertMsg "Minimum repayment amount must be less than or equal to loan amount" (minimumRepaymentAmount <= amount)

        (loanLimitCid, loanLimit) <- fetchByKey @LoanLimit bank
        
        assertMsg "Cannot loan more than loan limit" (amount <= loanLimit.amount)

        let newLimit = loanLimit.amount - amount
        archive loanLimitCid
        create LoanLimit with amount = newLimit, ..

        loanCid <- 
          create Loan with 
            id = loanId
            disbursementCids = []
            approvedAmount = amount
            repaidAmount = 0.0; ..

        void $ create RepaymentRestriction with minimumAmount = minimumRepaymentAmount; ..

        pure loanCid
